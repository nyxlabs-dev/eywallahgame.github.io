<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Highway Race</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #score { position: absolute; top: 10px; left: 10px; color: white; font-size: 24px; }
        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 48px; text-align: center; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="game-over">Game Over<br>Click to Restart</div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        const scoreEl = document.getElementById('score');
        const gameOverEl = document.getElementById('game-over');
        let score = 0;
        let gameOver = false;

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 5;
        camera.position.z = 10;
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // m/sÂ²
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(30, 400);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const groundBody = new CANNON.Body({
            mass: 0, // mass == 0 makes the body static
            shape: new CANNON.Plane(),
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // Player vehicle
        const carGeometry = new THREE.BoxGeometry(2, 1, 4);
        const carMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const car = new THREE.Mesh(carGeometry, carMaterial);
        car.position.y = 1;
        scene.add(car);

        const carBody = new CANNON.Body({
            mass: 5,
            position: new CANNON.Vec3(0, 1, 0),
            shape: new CANNON.Box(new CANNON.Vec3(1, 0.5, 2)),
        });
        world.addBody(carBody);

        // Vehicle controls
        const keyMap = {};
        document.addEventListener('keydown', (event) => (keyMap[event.code] = true));
        document.addEventListener('keyup', (event) => (keyMap[event.code] = false));

        const moveSpeed = 20;
        const turnSpeed = 2;

        function updateCar() {
            if (keyMap['KeyW']) {
                carBody.velocity.z = -moveSpeed;
            } else if (keyMap['KeyS']) {
                carBody.velocity.z = moveSpeed;
            } else {
                carBody.velocity.z = 0;
            }

            if (keyMap['KeyA']) {
                carBody.angularVelocity.y = turnSpeed;
            } else if (keyMap['KeyD']) {
                carBody.angularVelocity.y = -turnSpeed;
            } else {
                carBody.angularVelocity.y = 0;
            }
        }
        
        // Traffic
        const traffic = [];
        const trafficCount = 20;

        function spawnTraffic() {
            for (let i = 0; i < trafficCount; i++) {
                const tCarGeometry = new THREE.BoxGeometry(2, 1, 4);
                const tCarMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                const tCar = new THREE.Mesh(tCarGeometry, tCarMaterial);
                scene.add(tCar);

                const tCarBody = new CANNON.Body({
                    mass: 5,
                    shape: new CANNON.Box(new CANNON.Vec3(1, 0.5, 2)),
                });
                world.addBody(tCarBody);

                traffic.push({ mesh: tCar, body: tCarBody });
                resetTraffic(i);
            }
        }

        function resetTraffic(i) {
            const t = traffic[i];
            t.body.position.x = (Math.random() - 0.5) * 25;
            t.body.position.z = -100 - Math.random() * 200;
            t.body.velocity.z = 10 + Math.random() * 10;
            t.body.angularVelocity.y = 0;
            t.body.quaternion.set(0,0,0,1);
        }

        spawnTraffic();

        carBody.addEventListener('collide', (e) => {
            if (!gameOver) {
                gameOver = true;
                gameOverEl.style.display = 'block';
                carBody.velocity.set(0, 0, 0);
                carBody.angularVelocity.set(0, 0, 0);
            }
        });

        document.addEventListener('click', () => {
            if (gameOver) {
                gameOver = false;
                gameOverEl.style.display = 'none';
                score = 0;
                carBody.position.set(0, 1, 0);
                carBody.quaternion.set(0,0,0,1);
                traffic.forEach((t,i) => resetTraffic(i));
            }
        });
        
        // Animation loop
        function animate() {
            if (gameOver) {
                return;
            }
            requestAnimationFrame(animate);

            world.step(1 / 60);

            updateCar();

            car.position.copy(carBody.position);
            car.quaternion.copy(carBody.quaternion);

            traffic.forEach((t, i) => {
                t.mesh.position.copy(t.body.position);
                t.mesh.quaternion.copy(t.body.quaternion);

                if (t.body.position.z > car.position.z + 20) {
                    resetTraffic(i);
                }
            });

            score += Math.max(0, -carBody.velocity.z * 0.1);
            scoreEl.innerText = 'Score: ' + Math.floor(score);

            camera.position.x = car.position.x;
            camera.position.y = car.position.y + 5;
            camera.position.z = car.position.z + 10;
            camera.lookAt(car.position);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>